<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vue2 + Ant Design Vue 模态框管理器 (懒加载 + 隐藏/销毁分离)</title>
  <!-- 引入 Ant Design Vue 样式 -->
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/ant-design-vue/1.7.8/antd.min.css">
  <!-- 引入 Vue 2 -->
  <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.7.16/vue.min.js"></script>
  <!-- 引入 Ant Design Vue (兼容 Vue2 的 1.x 版本) -->
  <script src="https://cdn.bootcdn.net/ajax/libs/ant-design-vue/1.7.8/antd.min.js"></script>
  <!-- 引入 Prism.js 用于语法高亮 -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body>
  <div id="app">
    <div style="max-width: 1200px; margin: 0 auto; padding: 20px;">
      <h2>Vue2 + Ant Design Vue 模态框管理器 (懒加载 + 隐藏/销毁分离)</h2>
      <div style="margin-bottom: 20px;">
        <a-button type="primary" @click="openCustomModal">打开自定义模态框</a-button>
        <a-button type="danger" @click="openConfirmModal" style="margin-left: 10px;">打开确认模态框</a-button>
        <a-button type="dashed" @click="openByComponentName" style="margin-left: 10px;">通过组件名打开模态框</a-button>
        <a-button type="warning" @click="openModalPromiseStyle" style="margin-left: 10px;">Promise风格打开</a-button>
        <a-button type="default" @click="closeAllModals" style="margin-left: 10px;">关闭所有模态框</a-button>
      </div>

      <h3>当前打开的模态框:</h3>
      <div style="margin-bottom: 20px;">
        <span v-if="openModals.length === 0">无</span>
        <a-tag 
          v-for="modal in openModals" 
          :key="modal.id" 
          color="blue"
        >
          {{ modal.title }} (ID: {{ modal.id }}, 类型: {{ modal.type }})
        </a-tag>
      </div>

      <h3>调用方法示例：</h3>
      <div class="code-examples">
        <div class="example-section">
          <h4>1. Promise 风格（openModal）：</h4>
          <pre><code class="language-javascript">// 原生Promise风格，使用try/catch捕获错误
try {
  const result = await ModalManager.openModal(
    'CustomModal', // 直接使用组件名，自动懒加载
    { 
      title: 'Promise风格模态框',
      modalKey: 'promise_modal'
    }
  );
  // 模态框成功确认
  console.log('模态框确认返回数据：', result.data);
  this.$message.success('操作成功！');
} catch (error) {
  // 捕获取消或错误
  if (error.isCanceled) {
    console.log('模态框被取消：', error);
    this.$message.info('操作已取消');
  } else {
    console.error('模态框打开失败：', error);
    this.$message.error('操作失败！');
  }
}</code></pre>
        </div>

        <div class="example-section">
          <h4>2. Await-to-js 风格（toOpenModal）：</h4>
          <pre><code class="language-javascript">// Await-to-js风格，无需try/catch，返回[err, result]
const [err, result] = await ModalManager.toOpenModal(
  'CustomModal', // 组件名懒加载
  { 
    title: 'Await-to-js风格模态框',
    modalKey: 'await_to_js_modal'
  }
);

if (err) {
  // 模态框被取消或发生错误
  if (err.isCanceled) {
    console.log('模态框被取消：', err);
    this.$message.info('操作已取消');
  } else {
    console.error('模态框打开失败：', err);
    this.$message.error('操作失败！');
  }
} else {
  // 模态框成功确认
  console.log('模态框确认返回数据：', result.data);
  this.$message.success(`操作成功：${result.data.inputValue}`);
}</code></pre>
        </div>

        <div class="example-section">
          <h4>3. 懒加载组件注册示例：</h4>
          <pre><code class="language-javascript">// 注册懒加载组件
ModalManager.registerLazyComponent('CustomModal', () => {
  // 实际项目中可以替换为 import() 动态导入
  return Promise.resolve({
    // 组件定义
    props: { /* ... */ },
    template: `/* ... */`,
    methods: { /* ... */ }
  });
});

// 也可以注册普通组件
ModalManager.registerComponent('SimpleModal', {
  props: { /* ... */ },
  template: `/* ... */`
});</code></pre>
        </div>
        
        <div class="example-section">
          <h4>4. 隐藏/销毁模态框：</h4>
          <pre><code class="language-javascript">// 隐藏模态框（仅隐藏，不销毁实例）
ModalManager.hideModal('modal_id');

// 销毁模态框（完全销毁，释放内存）
ModalManager.destroyModal('modal_id');</code></pre>
        </div>
        
        <div class="example-section">
          <h4>5. 内嵌模态框示例（懒加载）：</h4>
          <pre><code class="language-javascript">// 在模态框组件内部打开另一个模态框（自动懒加载）
async openNestedModalPromise() {
  try {
    const result = await ModalManager.openModal(
      'NestedModal', // 懒加载内嵌组件
      { 
        title: 'Promise风格内嵌模态框',
        modalKey: 'nested_modal_' + this.modalId,
        parentModalId: this.modalId
      }
    );
    console.log('内嵌模态框确认：', result.data);
    this.$message.success(`内嵌模态框返回: ${JSON.stringify(result.data)}`);
  } catch (error) {
    if (!error.isCanceled) {
      this.$message.error('内嵌模态框操作失败');
    }
  }
}</code></pre>
        </div>
      </div>
      
      <h3>API 文档</h3>
      <div class="code-examples">
        <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
          <thead>
            <tr style="background-color: #f0f2f5;">
              <th style="border: 1px solid #e8e8e8; padding: 8px; text-align: left;">方法名</th>
              <th style="border: 1px solid #e8e8e8; padding: 8px; text-align: left;">API风格</th>
              <th style="border: 1px solid #e8e8e8; padding: 8px; text-align: left;">参数</th>
              <th style="border: 1px solid #e8e8e8; padding: 8px; text-align: left;">返回值</th>
              <th style="border: 1px solid #e8e8e8; padding: 8px; text-align: left;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: 1px solid #e8e8e8; padding: 8px;"><code>openModal</code></td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">Promise</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">componentOrName, config</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">Promise&lt;{data, modalId}&gt;</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">原生Promise风格，支持组件名懒加载</td>
            </tr>
            <tr>
              <td style="border: 1px solid #e8e8e8; padding: 8px;"><code>toOpenModal</code></td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">Await-to-js</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">componentOrName, config</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">[err, result]</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">Await-to-js风格，支持懒加载</td>
            </tr>
            <tr>
              <td style="border: 1px solid #e8e8e8; padding: 8px;"><code>registerComponent</code></td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">注册</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">name, component</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">void</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">注册普通组件（立即加载）</td>
            </tr>
            <tr>
              <td style="border: 1px solid #e8e8e8; padding: 8px;"><code>registerLazyComponent</code></td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">注册</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">name, loader</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">void</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">注册懒加载组件（调用时加载）</td>
            </tr>
            <tr>
              <td style="border: 1px solid #e8e8e8; padding: 8px;"><code>hideModal</code></td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">基础</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">modalId</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">Boolean</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">隐藏模态框（不销毁）</td>
            </tr>
            <tr>
              <td style="border: 1px solid #e8e8e8; padding: 8px;"><code>destroyModal</code></td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">基础</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">modalId</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">Boolean</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">销毁模态框（释放内存）</td>
            </tr>
            <tr>
              <td style="border: 1px solid #e8e8e8; padding: 8px;"><code>closeAllModals</code></td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">基础</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">无</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">无</td>
              <td style="border: 1px solid #e8e8e8; padding: 8px;">关闭所有模态框</td>
            </tr>
          </tbody>
        </table>
        
        <div style="margin-top: 20px; padding: 15px; background: #e6f7ff; border-radius: 4px;">
          <h4 style="margin-top: 0; color: #1890ff;">懒加载优势说明</h4>
          <ul style="margin: 5px 0; padding-left: 20px;">
            <li><strong>减小初始体积</strong>：组件代码只在调用时加载，初始加载时不包含所有模态框代码</li>
            <li><strong>按需加载</strong>：用户未使用的模态框不会加载，节省网络资源和内存</li>
            <li><strong>兼容原有用法</strong>：支持组件对象直接传入，也支持字符串名称懒加载</li>
            <li><strong>缓存机制</strong>：加载过的组件会缓存，重复调用不会重复加载</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- ========== 1. 独立的 ModalManager 模块 ========== -->
  <script>
    // 模块化封装，支持后续导出为UMD/ES模块
    (function(window, Vue) {
      // 防止重复定义
      if (window.ModalManager) {
        console.warn('ModalManager 已存在，跳过重复定义');
        return;
      }

      // ========== 模态框管理器核心实现（懒加载 + 隐藏/销毁分离） ==========
      const ModalManager = {
        // 存储模态框实例（包含隐藏状态）
        modals: new Map(),
        // 缓存组件构造器，避免重复创建
        constructorCache: new Map(),
        // 注册的组件（普通组件）
        registeredComponents: new Map(),
        // 懒加载组件加载器
        lazyComponentLoaders: new Map(),
        // 已加载的懒组件缓存
        lazyComponentCache: new Map(),
        
        /**
         * 生成唯一ID
         * @returns {string} 唯一模态框ID
         */
        generateId() {
          return `modal_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        },

        /**
         * 注册普通组件（立即加载）
         * @param {string} name 组件名称
         * @param {Object} component Vue组件对象
         */
        registerComponent(name, component) {
          this.registeredComponents.set(name, component);
          console.log(`组件 ${name} 已注册`);
        },

        /**
         * 注册懒加载组件（调用时才加载）
         * @param {string} name 组件名称
         * @param {Function} loader 返回Promise的加载函数
         */
        registerLazyComponent(name, loader) {
          if (typeof loader !== 'function') {
            throw new Error('懒加载组件的loader必须是返回Promise的函数');
          }
          this.lazyComponentLoaders.set(name, loader);
          console.log(`懒加载组件 ${name} 已注册加载器`);
        },

        /**
         * 加载懒组件（内部使用）
         * @param {string} name 组件名称
         * @returns {Promise<Object>} Vue组件对象
         */
        async loadLazyComponent(name) {
          // 先检查缓存
          if (this.lazyComponentCache.has(name)) {
            return this.lazyComponentCache.get(name);
          }
          
          // 检查是否有加载器
          const loader = this.lazyComponentLoaders.get(name);
          if (!loader) {
            throw new Error(`未找到名为 "${name}" 的懒加载组件加载器`);
          }
          
          // 执行加载器
          try {
            const component = await loader();
            // 缓存加载结果
            this.lazyComponentCache.set(name, component);
            console.log(`懒加载组件 ${name} 已加载并缓存`);
            return component;
          } catch (error) {
            console.error(`加载懒组件 ${name} 失败:`, error);
            throw new Error(`加载组件 ${name} 失败: ${error.message}`);
          }
        },

        /**
         * 获取组件（支持对象、字符串组件名、懒加载组件）
         * @param {string|Object} componentOrName 组件名称或组件对象
         * @returns {Promise<Object>} Vue组件对象
         */
        async getComponent(componentOrName) {
          // 如果是组件对象，直接返回
          if (typeof componentOrName === 'object' && componentOrName.template) {
            return componentOrName;
          }
          
          // 如果是字符串，先查普通组件，再查懒加载组件
          if (typeof componentOrName === 'string') {
            const name = componentOrName;
            
            // 1. 检查普通组件
            if (this.registeredComponents.has(name)) {
              return this.registeredComponents.get(name);
            }
            
            // 2. 检查懒加载组件（异步加载）
            if (this.lazyComponentLoaders.has(name)) {
              return await this.loadLazyComponent(name);
            }
            
            // 3. 未找到
            throw new Error(`未找到名为 "${name}" 的组件（普通组件或懒加载组件）`);
          }
          
          throw new Error('组件参数必须是组件对象或已注册的组件名称');
        },

        // ========== 核心 API 实现 - Promise 风格 ==========
        /**
         * 打开模态框（Promise风格：原生Promise，需try/catch）
         * @param {string|Object} componentOrName 组件名称或组件对象
         * @param {Object} config 模态框配置
         * @returns {Promise<Object>} 包含data和modalId的结果对象
         */
        async openModal(componentOrName, config = {}) {
          // 异步获取组件（支持懒加载）
          const component = await this.getComponent(componentOrName);
          
          // 从config中提取modalKey和其他props
          const { modalKey, ...props } = config;
          
          // 防重复打开：如果指定了key且已存在，则返回现有模态框的Promise
          if (modalKey && this.modals.has(modalKey)) {
            const existingModal = this.modals.get(modalKey);
            console.warn(`模态框[${modalKey}]已打开，避免重复创建`);
            
            // 如果模态框被隐藏了，重新显示它
            if (existingModal.hidden) {
              this.showModal(modalKey);
            }
            
            return existingModal.promise;
          }

          return new Promise((resolve, reject) => {
            const modalId = modalKey || this.generateId();
            // 缓存构造器，提升性能
            let ModalConstructor = this.constructorCache.get(component);
            if (!ModalConstructor) {
              ModalConstructor = Vue.extend(component);
              this.constructorCache.set(component, ModalConstructor);
            }

            // 初始化组件实例
            const modalInstance = new ModalConstructor({
              el: document.createElement('div'),
              propsData: {
                ...props,
                modalId,
                resolve: (data) => {
                  console.log('Modal resolved (Promise风格):', data);
                  resolve({ data, modalId });
                  // 移除已完成的模态框
                  this.modals.delete(modalId);
                },
                reject: (data) => {
                  console.log('Modal rejected (Promise风格):', data);
                  reject(data);
                  // 移除已取消的模态框
                  this.modals.delete(modalId);
                }
              }
            });
            
            // 挂载模态框到页面
            this.mountModal(modalInstance);
            
            // 存储实例和对应的Promise（包含隐藏状态）
            this.modals.set(modalId, {
              instance: modalInstance,
              promise: Promise.resolve({ data: {}, modalId }),
              title: props.title || component.name || '未知模态框',
              hidden: false, // 初始状态为非隐藏
              type: 'normal' // 模态框类型
            });
          });
        },

        // ========== 核心 API 实现 - Await-to-js 风格 ==========
        /**
         * Await-to-js风格的打开模态框方法（返回[err, result]，无需try/catch）
         * @param {string|Object} componentOrName 组件名称或组件对象
         * @param {Object} config 模态框配置
         * @returns {Promise<Array>} [err, result] 数组
         */
        async toOpenModal(componentOrName, config = {}) {
          try {
            const result = await this.openModal(componentOrName, config);
            return [null, result]; // [error, result] 格式
          } catch (error) {
            // 如果是用户取消，仍然返回错误，但标记为取消
            if (error.isCanceled) {
              return [error, null]; // [cancellation, null]
            }
            // 如果是其他错误，返回错误对象
            return [error, null]; // [error, null]
          }
        },

        // ========== 基础操作方法 ==========
        /**
         * 显示模态框
         * @param {string} modalId 模态框ID
         * @returns {boolean} 操作是否成功
         */
        showModal(modalId) {
          const modalItem = this.modals.get(modalId);
          if (!modalItem) {
            console.warn('未找到要显示的模态框:', modalId);
            return false;
          }
          
          if (modalItem.instance && !modalItem.hidden) {
            console.log('模态框已经是显示状态:', modalId);
            return true;
          }
          
          // 设置模态框可见
          modalItem.instance.visible = true;
          modalItem.hidden = false;
          console.log('模态框已显示:', modalId);
          return true;
        },

        /**
         * 隐藏模态框（仅隐藏，不销毁实例）
         * @param {string} modalId 模态框ID
         * @returns {boolean} 操作是否成功
         */
        hideModal(modalId) {
          const modalItem = this.modals.get(modalId);
          if (!modalItem) {
            console.warn('未找到要隐藏的模态框:', modalId);
            return false;
          }
          
          if (modalItem.instance && modalItem.hidden) {
            console.log('模态框已经是隐藏状态:', modalId);
            return true;
          }
          
          // 隐藏模态框
          modalItem.instance.visible = false;
          modalItem.hidden = true;
          console.log('模态框已隐藏:', modalId);
          return true;
        },

        /**
         * 销毁模态框（完全销毁，释放内存）
         * @param {string} modalId 模态框ID
         * @returns {boolean} 操作是否成功
         */
        destroyModal(modalId) {
          const modalItem = this.modals.get(modalId);
          if (!modalItem) {
            console.warn('未找到要销毁的模态框:', modalId);
            return false;
          }
          
          const { instance } = modalItem;
          
          // 确保模态框可见状态被设置为false
          if (instance.visible) {
            instance.visible = false;
          }
          
          // 优化：动态获取动画时长（兼容不同组件的动画）
          const transitionDuration = this.getTransitionDuration(instance.$el);
          const delay = transitionDuration || 300;

          // 延迟卸载，适配动画
          setTimeout(() => {
            try {
              // 安全移除DOM：增加父节点校验
              if (instance.$el && instance.$el.parentNode) {
                document.body.removeChild(instance.$el);
              }
              // 销毁实例前解绑所有事件
              instance.$off();
              // 销毁组件实例
              instance.$destroy();
              // 清理数据引用
              for (const key in instance) {
                if (instance.hasOwnProperty(key) && key !== '$options') {
                  instance[key] = null;
                }
              }
            } catch (e) {
              console.error('销毁模态框时出错:', e);
            } finally {
              // 确保从Map中移除
              this.modals.delete(modalId);
              console.log('模态框已完全销毁:', modalId);
            }
          }, delay);
          
          return true;
        },

        /**
         * 关闭模态框（隐藏+销毁的组合操作）
         * @param {string} modalId 模态框ID
         */
        closeModal(modalId) {
          this.hideModal(modalId);
          this.destroyModal(modalId);
        },

        /**
         * 关闭所有模态框
         */
        closeAllModals() {
          // 转换为数组避免遍历过程中Map结构变化
          const modalIds = Array.from(this.modals.keys());
          console.log('准备关闭所有模态框:', modalIds);
          modalIds.forEach(id => this.destroyModal(id));
          console.log('已关闭所有模态框');
        },

        /**
         * 检查模态框是否存在
         * @param {string|Object} modalIdOrInstance 模态框ID或实例
         * @returns {boolean} 是否存在
         */
        hasModal(modalIdOrInstance) {
          if (typeof modalIdOrInstance === 'string') {
            return this.modals.has(modalIdOrInstance);
          }
          for (const item of this.modals.values()) {
            if (item.instance === modalIdOrInstance) return true;
          }
          return false;
        },

        /**
         * 获取所有打开的模态框列表
         * @returns {Array} 模态框列表
         */
        getOpenModals() {
          const openModals = [];
          this.modals.forEach((item, id) => {
            if (!item.hidden) {
              openModals.push({
                id,
                title: item.title,
                type: item.type
              });
            }
          });
          return openModals;
        },

        /**
         * 挂载模态框到body
         * @param {Object} modalInstance 模态框实例
         */
        mountModal(modalInstance) {
          if (!modalInstance.$el || modalInstance.$el.parentNode) return;
          document.body.appendChild(modalInstance.$el);
          // 确保DOM渲染完成后再显示
          Vue.nextTick(() => {
            modalInstance.visible = true;
          });
        },

        /**
         * 动态获取元素的过渡动画时长
         * @param {HTMLElement} el DOM元素
         * @returns {number} 动画时长(ms)
         */
        getTransitionDuration(el) {
          if (!el) return 0;
          const computedStyle = window.getComputedStyle(el);
          const transitionDuration = computedStyle.transitionDuration || '0s';
          return parseFloat(transitionDuration) * 1000;
        }
      };

      // 暴露到全局
      window.ModalManager = ModalManager;

      // 支持ES模块导出（如果环境支持）
      if (typeof module !== 'undefined' && module.exports) {
        module.exports = ModalManager;
      }

    })(window, Vue);
  </script>

  <!-- ========== 2. 组件注册和主Vue实例 ========== -->
  <script>
    // ========== 注册懒加载模态框组件 ==========
    // 注册CustomModal懒加载组件
    ModalManager.registerLazyComponent('CustomModal', () => {
      // 实际项目中可以替换为：return import('./CustomModal.vue')
      return Promise.resolve({
        props: {
          title: {
            type: String,
            default: '自定义模态框'
          },
          visible: {
            type: Boolean,
            default: false
          },
          modalId: {
            type: String,
            default: ''
          },
          resolve: {
            type: Function,
            required: true
          },
          reject: {
            type: Function,
            required: true
          }
        },
        template: `
          <a-modal
            :title="title"
            :visible="visible"
            :maskClosable="false"
            :closable="true"
            width="400px"
            @cancel="handleCancel"
            @ok="handleConfirm"
          >
            <div>这是自定义模态框（ID：{{modalId}}）- 懒加载版本</div>
            <a-input 
              v-model="inputValue" 
              placeholder="请输入内容" 
              style="margin-top: 10px;"
            />
            <div style="margin-top: 10px;">
              <a-button type="primary" size="small" @click="openNestedModalPromise">Promise风格内嵌</a-button>
              <a-button type="dashed" size="small" @click="openNestedModalAwait" style="margin-left: 8px;">Await风格内嵌</a-button>
              <a-button type="default" size="small" @click="hideCurrentModal" style="margin-left: 8px;">隐藏当前模态框</a-button>
            </div>
          </a-modal>
        `,
        data() {
          return {
            inputValue: ''
          };
        },
        methods: {
          handleCancel() {
            console.log('CustomModal handleCancel called');
            this.visible = false;
            this.reject({ 
              reason: '用户关闭/取消模态框', 
              modalId: this.modalId,
              isCanceled: true
            });
            ModalManager.destroyModal(this.modalId);
          },
          handleConfirm() {
            console.log('CustomModal handleConfirm called');
            this.visible = false;
            this.resolve({ inputValue: this.inputValue, modalId: this.modalId });
            ModalManager.destroyModal(this.modalId);
          },
          // Promise风格打开内嵌模态框
          async openNestedModalPromise() {
            try {
              const result = await ModalManager.openModal(
                'NestedModal', 
                { 
                  title: 'Promise风格内嵌模态框',
                  modalKey: 'nested_promise_' + this.modalId,
                  parentModalId: this.modalId
                }
              );
              console.log('Promise风格内嵌模态框确认：', result.data);
              this.$message.success(`Promise内嵌返回: ${JSON.stringify(result.data)}`);
            } catch (error) {
              if (!error.isCanceled) {
                this.$message.error('Promise内嵌模态框操作失败');
              }
            }
          },
          // Await-to-js风格打开内嵌模态框
          async openNestedModalAwait() {
            const [err, result] = await ModalManager.toOpenModal(
              'NestedModal', 
              { 
                title: 'Await-to-js风格内嵌模态框',
                modalKey: 'nested_await_' + this.modalId,
                parentModalId: this.modalId
              }
            );
            
            if (!err) {
              console.log('Await-to-js风格内嵌模态框确认：', result.data);
              this.$message.success(`Await内嵌返回: ${JSON.stringify(result.data)}`);
            }
          },
          hideCurrentModal() {
            ModalManager.hideModal(this.modalId);
            this.$message.info('当前模态框已隐藏');
          }
        },
        beforeDestroy() {
          this.inputValue = '';
        }
      });
    });

    // 注册ConfirmModal懒加载组件
    ModalManager.registerLazyComponent('ConfirmModal', () => {
      return Promise.resolve({
        props: {
          message: {
            type: String,
            default: '确定要执行此操作吗？'
          },
          visible: {
            type: Boolean,
            default: false
          },
          modalId: {
            type: String,
            default: ''
          },
          resolve: {
            type: Function,
            required: true
          },
          reject: {
            type: Function,
            required: true
          }
        },
        template: `
          <a-modal
            title="确认操作"
            :visible="visible"
            :maskClosable="false"
            :closable="false"
            width="300px"
            @cancel="handleCancel"
            @ok="handleConfirm"
          >
            <div style="color: #666;">{{ message }}</div>
            <div style="margin-top: 10px;">
              <a-button type="primary" size="small" @click="openNestedConfirmPromise">Promise内嵌确认</a-button>
              <a-button type="dashed" size="small" @click="openNestedConfirmAwait" style="margin-left: 8px;">Await内嵌确认</a-button>
            </div>
          </a-modal>
        `,
        methods: {
          handleCancel() {
            console.log('ConfirmModal handleCancel called');
            this.visible = false;
            this.reject({ 
              reason: '用户取消操作', 
              modalId: this.modalId,
              isCanceled: true
            });
            ModalManager.destroyModal(this.modalId);
          },
          handleConfirm() {
            console.log('ConfirmModal handleConfirm called');
            this.visible = false;
            this.resolve({ confirmed: true, modalId: this.modalId });
            ModalManager.destroyModal(this.modalId);
          },
          async openNestedConfirmPromise() {
            try {
              const result = await ModalManager.openModal(
                'ConfirmModal', 
                { 
                  message: 'Promise风格内嵌确认！',
                  title: 'Promise内嵌确认',
                  modalKey: 'nested_confirm_promise_' + this.modalId,
                  parentModalId: this.modalId
                }
              );
              this.$message.success('Promise内嵌确认已完成');
            } catch (error) {
              if (!error.isCanceled) {
                this.$message.error('Promise内嵌确认失败');
              }
            }
          },
          async openNestedConfirmAwait() {
            const [err, result] = await ModalManager.toOpenModal(
              'ConfirmModal', 
              { 
                message: 'Await-to-js风格内嵌确认！',
                title: 'Await内嵌确认',
                modalKey: 'nested_confirm_await_' + this.modalId,
                parentModalId: this.modalId
              }
            );
            
            if (!err) {
              this.$message.success('Await内嵌确认已完成');
            }
          }
        }
      });
    });

    // 注册NestedModal懒加载组件
    ModalManager.registerLazyComponent('NestedModal', () => {
      return Promise.resolve({
        props: {
          title: {
            type: String,
            default: '内嵌模态框'
          },
          visible: {
            type: Boolean,
            default: false
          },
          modalId: {
            type: String,
            default: ''
          },
          parentModalId: {
            type: String,
            default: ''
          },
          resolve: {
            type: Function,
            required: true
          },
          reject: {
            type: Function,
            required: true
          }
        },
        template: `
          <a-modal
            :title="title"
            :visible="visible"
            :maskClosable="false"
            :closable="true"
            width="350px"
            @cancel="handleCancel"
            @ok="handleConfirm"
          >
            <div>这是内嵌模态框（ID：{{modalId}}）- 懒加载版本</div>
            <div>父模态框ID：{{parentModalId}}</div>
            <a-input 
              v-model="inputValue" 
              placeholder="内嵌模态框输入" 
              style="margin-top: 10px;"
            />
          </a-modal>
        `,
        data() {
          return {
            inputValue: ''
          };
        },
        methods: {
          handleCancel() {
            this.visible = false;
            this.reject({ 
              reason: '内嵌模态框被取消', 
              modalId: this.modalId,
              parentModalId: this.parentModalId,
              isCanceled: true
            });
            ModalManager.destroyModal(this.modalId);
          },
          handleConfirm() {
            this.visible = false;
            this.resolve({ 
              inputValue: this.inputValue, 
              modalId: this.modalId,
              parentModalId: this.parentModalId
            });
            ModalManager.destroyModal(this.modalId);
          }
        }
      });
    });

    // ========== 主 Vue 实例 ==========
    new Vue({
      el: '#app',
      data() {
        return {
          openModals: []
        };
      },
      mounted() {
        // 定期更新打开的模态框列表
        setInterval(() => {
          this.updateOpenModals();
        }, 1000); // 每秒更新一次
      },
      methods: {
        updateOpenModals() {
          this.openModals = ModalManager.getOpenModals();
        },
        
        // 常规方式打开模态框（使用组件名懒加载）
        async openCustomModal() {
          const [err, result] = await ModalManager.toOpenModal(
            'CustomModal', // 直接使用组件名，自动懒加载
            { 
              title: 'AntV 自定义模态框',
              modalKey: 'custom_modal'
            }
          );

          if (err) {
            if (err.isCanceled) {
              console.log('模态框被取消：', err);
              this.$message.info('模态框已取消');
            } else {
              console.error('模态框打开失败：', err);
              this.$message.error('模态框打开失败');
            }
          } else {
            console.log('模态框确认返回数据：', result.data);
            this.$message.success(`你输入的内容是：${result.data.inputValue}（模态框ID：${result.modalId}）`);
          }
        },

        // 打开确认模态框（懒加载）
        async openConfirmModal() {
          const [err, result] = await ModalManager.toOpenModal(
            'ConfirmModal', // 懒加载
            { 
              message: '确定要删除这条数据吗？',
              modalKey: 'confirm_modal'
            }
          );

          if (err) {
            if (err.isCanceled) {
              console.log('确认模态框被取消：', err);
              this.$message.warning('删除操作已取消');
            } else {
              console.error('确认模态框打开失败：', err);
              this.$message.error('确认模态框打开失败');
            }
          } else {
            this.$message.success('删除操作已确认');
          }
        },

        // 通过组件名打开模态框（懒加载核心示例）
        async openByComponentName() {
          const [err, result] = await ModalManager.toOpenModal(
            'CustomModal', // 仅传入组件名，自动懒加载
            { 
              title: '通过组件名懒加载的模态框',
              modalKey: 'component_name_modal'
            }
          );

          if (err) {
            if (err.isCanceled) {
              console.log('组件名模态框被取消：', err);
              this.$message.info('组件名模态框已取消');
            } else {
              console.error('组件名模态框打开失败：', err);
              this.$message.error('组件名模态框打开失败');
            }
          } else {
            console.log('组件名模态框确认返回数据：', result.data);
            this.$message.success(`通过组件名打开的模态框输入内容：${result.data.inputValue}（模态框ID：${result.modalId}）`);
          }
        },

        // Promise风格打开模态框（懒加载）
        async openModalPromiseStyle() {
          try {
            const result = await ModalManager.openModal(
              'CustomModal', // 懒加载
              { 
                title: 'Promise风格模态框示例',
                modalKey: 'promise_demo_modal'
              }
            );
            console.log('Promise风格模态框返回：', result.data);
            this.$message.success(`Promise风格：你输入的内容是 ${result.data.inputValue}`);
          } catch (error) {
            if (error.isCanceled) {
              console.log('Promise风格模态框被取消：', error);
              this.$message.info('Promise风格模态框已取消');
            } else {
              console.error('Promise风格模态框出错：', error);
              this.$message.error('Promise风格模态框操作失败');
            }
          }
        },

        // 关闭所有模态框
        closeAllModals() {
          ModalManager.closeAllModals();
          this.$message.info('所有模态框已关闭');
        }
      },
      // 页面销毁时关闭所有模态框，防止内存泄漏
      beforeDestroy() {
        ModalManager.closeAllModals();
      }
    });

    // 初始化语法高亮
    document.addEventListener('DOMContentLoaded', function() {
      Prism.highlightAll();
    });
  </script>

  <style>
    body {
      height: auto;
      min-height: 100vh;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    
    .code-examples {
      margin-top: 30px;
      padding: 20px;
      background-color: #f9f9f9;
      border-radius: 8px;
      border: 1px solid #eee;
    }
    
    .example-section {
      margin-bottom: 25px;
    }
    
    .example-section h4 {
      margin-bottom: 10px;
      color: #333;
    }
    
    pre {
      margin: 0;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 4px;
      overflow-x: auto;
    }
    
    code {
      font-family: Consolas, Monaco, 'Courier New', monospace;
      font-size: 14px;
    }
  </style>
</body>
</html>